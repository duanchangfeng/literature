### Abstract 
Symbolic model checking based on Binary Decision Diagrams (BDDs) is one of the most celebrated breakthroughs in the area of formal verification. It was originally proposed in the context of hardware model checking, and advanced the state of the art in model-checking capability by several orders of magnitude in terms of the sizes of state spaces that could be explored successfully. More recently, it has been extended to the domain of software verification as well, and several BDDbased model checkers for Boolean programs and push-down systems have been developed. In this chapter, we summarize some of the key concepts and techniques that have emerged in this story of successful practical verification. 

### 摘要 
基于二进制决策图（BDDs）的符号模型检查是形式验证领域中最著名的突破之一。它最初是在硬件模型检查的背景下提出的，在可以成功探索的状态空间的大小方面，将模型检查能力的技术水平提高了几个数量级。最近，它也被扩展到了软件验证领域，并开发了几个基于BDD的布尔程序和下推系统的模型检查器。在本章中，我们总结了在这个成功的实际验证故事中出现的一些关键概念和技术。

### 8.1 Introduction 
Algorithms for temporal logic model checking [14] were initially implemented in an explicit-state manner. This means that all automata involved in verification were represented using explicit graph-based data structures. Such automata include the Kripke structures as well as Büchi automata and tableaux obtained from the temporal logic specifications. In particular, the edges of the graph (which are in the worst case quadratic in the number of nodes) were represented using adjacency lists, matrices, etc. From a theoretical perspective, the data structure used to represent the automata makes no difference whatsoever. From a practical perspective, however, this meant that model checkers could only handle automata with at most 103 to 106 reachable states [8]. Verification of most realistic systems was beyond the capability of such explicit-state engines. For example, a CPU with a single 32-bit register has more than 232 ≈ 4 × 109 possible states. Practical hardware verification via model checking had to wait for another breakthrough.

时间逻辑模型检查的算法[14]最初是以显式状态的方式实现的。这意味着所有参与验证的自动机都是用明确的基于图的数据结构表示的。这种自动机包括Kripke结构以及Büchi自动机和从时态逻辑规范中获得的tableaux。特别是，图的边（在最坏的情况下是节点数量的二次方）用邻接列表、矩阵等表示。从理论的角度来看，用于表示自动机的数据结构没有任何区别。然而，从实践的角度来看，这意味着模型检查器只能处理最多具有103到106个可达状态的自动机[8]。大多数现实系统的验证都超出了这种显式状态引擎的能力。例如，一个只有32位寄存器的CPU有超过232≈4×109的可能状态。通过模型检查的实际硬件验证不得不等待另一个突破。


The breakthrough appeared in the form of BDD-based symbolic model checking [8]. This paradigm uses a data structure called binary decision diagrams, BDDs, (see Chap. 7 and [1, 6]). BDDs are used to symbolically represent the transition relation of the automata or Kripke structures under analysis, and sets of states manipulated by the model-checking algorithm. Representing and manipulating transition relations and sets of states is sufficient for implementing model-checking algorithms for a wide range of temporal logics, for example, using the fixed-point construction described in Chap. 2. Since its inception, BDD-based symbolic model checking has revolutionized formal verification and formal methods in profound ways. First, it has enabled practical verification of industrial systems—beginning with hardware [7] and extending to software [3]. Second, it has led to important developments for BDDs, such as new types of BDDs [22], variable-ordering heuristics [2, 24] and efficient implementations [31]. Finally, it has paved the way to other forms of symbolic model checking, especially those using efficient SAT solvers [4] and interpolants [21]. In this chapter, we present some of the key concepts and techniques in the area of BDD-based symbolic model checking. More specifically, we use reduced ordered BDDs (or ROBDDs). Unless otherwise mentioned, we use BDD to mean ROBDD. The goal of this chapter is not to be a comprehensive exposition of this rich and wellstudied research area. Instead, we wish to present the basic ideas and algorithms to help someone unfamiliar with this topic get started, and to cite resources for the interested reader to find out more. The rest of this chapter is organized as follows. Section 8.2 presents preliminary definitions borrowed from other chapters in the book. Section 8.3 presents basic concepts used in the rest of the chapter. Section 8.4 represents symbolic model checking of Kripke structures for CTL, fair CTL, and LTL. Section 8.5 presents symbolic model checking of reachability properties of push-down systems represented as Boolean programs. Section 8.6 concludes the chapter. 8.2 Preliminaries Binary decision diagrams (BDDs) and their related concepts such as variable ordering and operations are presented in detail in Chap. 7. Therefore, we only give a brief overview of the BDD concepts and notation that are used in the rest of this chapter. Throughout, we assume that BDDs are ordered with respect to a fixed variable ordering and are reduced. For set X, we write P(X) to mean the powerset of X. For a propositional formula f, let Var(f) be the set of variables (a.k.a. atomic propositions) appearing in f . We assume that the reader is familiar with the basic concepts of temporal logic and its model-checking algorithms (see Chap. 2) and basic BDD operations (see Chap. 7). However, we use different notation and, for that reason, repeat some of the key definitions here. We refer the reader to earlier chapters for a more in-depth presentation of these topics.


突破出现在基于BDD的符号模型检查中[8]。这种范式使用一种叫做二进制决策图的数据结构，BDDs，（见第7章和[1，6]）。BDDs被用来象征性地表示所分析的自动机或Kripke结构的过渡关系，以及模型检查算法所操纵的状态集。表示和操作过渡关系和状态集足以实现广泛的时态逻辑的模型检查算法，例如，使用第2章中描述的定点构造。 自成立以来，基于BDD的符号模型检查以深刻的方式革新了形式验证和形式方法。首先，它使工业系统的实际验证成为可能--从硬件[7]开始，扩展到软件[3]。其次，它导致了BDDs的重要发展，如新类型的BDDs[22]、变量排序启发式方法[2，24]和高效的实现[31]。最后，它为其他形式的符号模型检查铺平了道路，特别是那些使用高效的SAT求解器[4]和插值器[21]。在本章中，我们介绍了基于BDD的符号模型检查领域中的一些关键概念和技术。更具体地说，我们使用还原有序的BDDs（或ROBDDs）。除非另有提及，我们用BDD来指代ROBDD。本章的目标不是要全面阐述这一丰富且研究透彻的研究领域。相反，我们希望介绍基本的想法和算法，以帮助不熟悉这一主题的人入门，并为感兴趣的读者引用资源以了解更多。本章的其余部分组织如下。第8.2节介绍了从本书其他章节中借用的初步定义。第8.3节介绍了本章其余部分使用的基本概念。第8.4节表示CTL、公平CTL和LTL的Kripke结构的符号模型检查。第8.5节介绍了以布尔程序表示的下推系统的可达性特性的符号模型检查。第8.6节是本章的结论。8.2 前言 二进制决策图（BDDs）及其相关概念，如变量排序和操作，将在第7章详细介绍。因此，我们只对本章其余部分所使用的BDD概念和符号做一个简要概述。在整个过程中，我们假设BDDs是相对于固定的变量排序的，并且是还原的。对于集合X，我们用P(X)表示X的幂集。对于一个命题公式f，让Var(f)表示f中出现的变量集（又称原子命题）。我们假设读者熟悉时态逻辑的基本概念及其模型检查算法（见第2章）和基本的BDD操作（见第7章）。然而，我们使用不同的符号，为此，在此重复一些关键的定义。我们建议读者在前面的章节中对这些主题进行更深入的介绍。


